---
title: 백준 1269번
image: https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/images/boj-og.png
description: '대칭 차집합'
---

import Callout from 'nextra-theme-docs/callout'
import Bleed from 'nextra-theme-docs/bleed'
import { SiJavascript, SiPython } from 'react-icons/si'

# 백준 1269번

## 문제

자연수를 원소로 갖는 공집합이 아닌 두 집합 A와 B가 있다. 이때, 두 집합의 대칭 차집합의 원소의 개수를 출력하는 프로그램을 작성하시오. 두 집합 A와 B가 있을 때, (A-B)와 (B-A)의 합집합을 A와 B의 대칭 차집합이라고 한다.

예를 들어, A = { 1, 2, 4 } 이고, B = { 2, 3, 4, 5, 6 } 라고 할 때, A-B = { 1 } 이고, B-A = { 3, 5, 6 } 이므로, 대칭 차집합의 원소의 개수는 1 + 3 = 4개이다.

<br/>

## 입력 및 출력

첫째 줄에 집합 A의 원소의 개수와 집합 B의 원소의 개수가 빈 칸을 사이에 두고 주어진다. 둘째 줄에는 집합 A의 모든 원소가, 셋째 줄에는 집합 B의 모든 원소가 빈 칸을 사이에 두고 각각 주어진다. 각 집합의 원소의 개수는 200,000을 넘지 않으며, 모든 원소의 값은 100,000,000을 넘지 않는다.

<CH.Code>

```bash input
3 5
1 2 4
2 3 4 5 6
```

```bash output
4
```

</CH.Code>

<br/>

## 풀이

수학의 <a href="https://en.wikipedia.org/wiki/Intersection_(set_theory)" target="_blank">차집합</a>에 대한 전형적인 문제였다.

<br/>

### 자바스크립트

#### 실패1

단순하게 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank"><code>.filter()</code></a>를 이용하여
집합 A에 있는 원소들 중 집합 B에는 없는 원소들, 그리고 그 반대의 경우를 생각해주었다.

```js
const input = require("fs")
  .readFileSync(0)
  .toString()
  .trim()
  .split("\n");

const [length, ...nums] = input;
const numA = +length.split(" ")[0]; // 집합 A의 원소의 개수 입력값 받기
const numB = +length.split(" ")[1]; // 집합 B의 원소의 개수 입력값 받기
const A = nums[0].split(" "); // 집합 A의 원소가 담긴 배열
const B = nums[1].split(" "); // 집합 B의 원소가 담긴 배열

// 집합 A에 있는 원소들 중 집합 B에는 없는 원소들만 골라낸다
const onlyA = A.filter((el) => !B.includes(el));
// 반대의 케이스
const onlyB = B.filter((el) => !A.includes(el));

console.log(onlyA.length + onlyB.length); // 각각의 두 집합의 차집합 원소의 개수들 더해준다.
```

<br/>

하지만 시간 초과가 나고 말았다.
그도 그럴 것이 집합의 원소의 개수는 200,000개가 넘어가기 때문에 `.filter()`는 선형시간 $O(n)$이 소요되기 때문에 시간 복잡도 측면에서는 그리 바람직해 보이지 않았다.

<br/>

#### 성공

이번에는 성능이 조금 더 낫다는 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank"><code>Set()</code></a>을 사용해보았다.

1. 먼저 집합 A와 집합 B의 원소들을 모두 `Set()`에 담아준다.
2. 이후 앞서 위에서 트라이했던 로직을 그대로 적용하여 다시 `Set()`에 담아준다.
   - <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/has" target="_blank"><code>.has()</code></a> 메소드를 사용하면 `Set()` 안에 해당 요소가 존재하는지 알 수 있다.

```js
const input = require("fs")
  .readFileSync(0)
  .toString()
  .trim()
  .split("\n");

const [length, ...nums] = input;
const numA = +length.split(" ")[0];
const numB = +length.split(" ")[1];
// nums로 따로 빼내온 원소들을 Set에 담아준다.
const A = new Set(nums[0].split(" ").map(Number));
const B = new Set(nums[1].split(" ").map(Number));

const onlyA = new Set([...A].filter((el) => !B.has(el)));
const onlyB = new Set([...B].filter((el) => !A.has(el)));
console.log([...onlyA].length + [...onlyB].length);
```
