---
title: 스택
image: https://www.tabnine.com/academy/wp-content/uploads/2020/10/academy_1.png
description: '스택 자료구조에 대하여 알아보자'
date: September 24th, 2022
---

import Callout from 'nextra-theme-docs/callout'
import Bleed from 'nextra-theme-docs/bleed'

## 정의

Last In, First Out(LIFO) 개념을 가진 선형 자료구조이다. 즉, 나중에 들어간 요소가 먼저 나오는 구조이다.
제일 쉬운 예로 바닥이 막힌 상자를 생각하면 되겠다.

<br/>

<center>
    <figure>
        <img src="http://cfs3.tistory.com/upload_control/download.blog?fhandle=YmxvZzEyNDIxQGZzMy50aXN0b3J5LmNvbTovYXR0YWNoLzAvOS5wbmc%3D" alt="queue" />
        <figcaption>출처: 안코덤</figcaption>
    </figure>
</center>

<br/>

## 시간 복잡도

1. 삭제나 삽입의 경우 맨 위에서 데이터를 삭제하거나 삽입하기 때문에 시간복잡도는 늘 $O(1)$의 시간복잡도를 가지게 된다.
2. 탐색의 경우 특정 데이터를 찾을 때까지 수행을 해야 하므로 $O(n)$의 시간복잡도를 가지게 된다.

<br/>

## 구현

### 배열 방식

#### 자바스크립트

스택이라는 빈 배열에 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push" target="_blank"><code>push()</code></a>를 이용하여 요소를 순차적으로 집어넣을 수 있고,
이후, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" target="_blank"><code>pop()</code></a>을 이용하여 맨 뒤쪽의 요소를 제거할 수 있다.

자바스크립트에선 배열의 중간 요소를 추가 및 삭제하는 로직을 사용하지 않았기 때문에 꽤 쉽게 구현이 가능하다.

<br/>

<center>
    <figure>
        <img src="https://media.geeksforgeeks.org/wp-content/uploads/growable-stack.png" alt="queue" />
        <figcaption>출처: GeeksforGeeks</figcaption>
    </figure>
</center>

<br/>

```js
const stack = [];

// Push
stack.push(1);
stack.push(2);
stack.push(3);
// label [1, 2, 3]
console.log(stack);

// Pop
stack.pop();
// label [1, 2]
console.log(stack);

// 최상단 값 가져오기
// label 2
console.log(stack[stack.length - 1]);
```

<br/>
<br/>

#### 파이썬

파이썬도 자바스크립트처럼 내장 함수가 존재한다. <a href="https://docs.python.org/3/library/array.html?highlight=append#array.array.append" target="_blank"><code>append()</code></a> 함수를 통해 요소를 배열의 맨 마지막에서부터
순차적으로 집어넣을 수 있다. 반대로 <a href="https://docs.python.org/3/library/array.html?highlight=pop#array.array.pop" target="_blank"><code>pop()</code></a> 함수를 통해 배열의 맨 마지막 요소를 제거할 수 있다.

```py
stack = []

# Append
stack.append(1);
stack.append(2);
stack.append(3);
# label [1, 2, 3]
print(stack)

# Pop
stack.pop()
# label [1, 2]
print(stack)

# 최상단 값 가져오기
# label 2
print(stack[-1])
```

<br/>

### 연결 리스트 방식

#### 자바스크립트

먼저 연결 리스트를 이루는 노드를 가리키기 위한 `Node`라는 클래스를 만들어준다.

`push(value)` 메소드는 새로운 노드에 `value` 값을 넣는 메소드이며, 반대로 `pop()`은 노드에 기록된 값을 제거하는 메소드이다. 마지막으로 `size()` 메소드는 해당 스택의 총 크기를 `return`한다.

```js
class Node {
    constructor(value) {
        this.value = value;
        this.next = null;
    }
}

class Stack {
    constructor() {
        this.top = null;
        this.size = 0;
    }

    push(value) {
        const node = new Node(value);
        node.next = this.top;
        this.top = node;
        this.size += 1;
    }

    pop() {
        const value = this.top.value;
        this.top = this.top.next;
        this.size -= 1;
        return value;
    }

    size() {
        return this.size;
    }
}

const stack = new Stack();

stack.push(1);
stack.push(2);
stack.push(3);
// label 3
console.log(stack.pop());
stack.push(4);
// label 4
console.log(stack.pop());
// label 2
console.log(stack.pop());
```

<br/>

#### 파이썬

자바스크립트와 구조적으로 비슷하다.

```py
class Node:
    def __init__(self, item, next):
        self.value = value
        self.next = next

class Stack:
    def __init__(self):
        self.top = None
        self.size = 0

    def push(self, value):
        self.next = Node(value, self.next)

    def pop(self):
        self.value = self.top.value
        self.next = self.top.next
        return value
```
