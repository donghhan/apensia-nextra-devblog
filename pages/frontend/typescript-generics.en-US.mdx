---
title: What are Generics in TypeScript?
image: https://bs-uploads.toptal.io/blackfish-uploads/components/blog_post_page/content/cover_image_file/cover_image/689069/regular_800x320_1105-A_Guide_to_Webpack_and_React_Dan_Newsletter-3213ef44db23c39d0c43ba54e63154a7.png
description: About overloading, polymorphism and generics
---

import Admonition from '@yozora/react-admonition'
import Bleed from 'nextra-theme-docs/bleed'

# Generics of TypeScript and Its Usage

## Call Signature

Let's say we have functions as below.

```ts
const add = (a, b) => a + b;
```

Our <a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#call-signatures" target="_blank">call signature</a>[^1] will as same as below:

```ts
const add = (a: any, b: any) => any;
```

As we did not set up any types for parameters `a`, `b` and its return value's type, TypeScript automatically set up all types as `any`.

<br/>

### Overloading

In JavaScript, functions can have a variety of arguments and types.
Here, <a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#function-overloads" target="_blank">overloading</a> happens when functions have multiple call signatures.

For instance, let's set types for `add` function explicitly.

<CH.Section>

```ts
type Add = {
    (a: number, b: number): number
    (a: number, b: string): number
}

// withClass[28:32] code-error
const add: Add = (a, b) => a + b; // Operator '+' cannot be applied to types 'number' and 'string | number'.(2365)
```

I set up type of `Add` for `add` function which takes [parameter `a` that is number type](focus://2[6:15],3[6:15]) and [parameter `b` that can be either string or number `b`](focus://2[17:26],3[17:26]), with [its return value type be number](focus://2[29:34],3[29:34]).
With doing this, we can configure types for multiple parameters and its return value type for function with overloading.

However, if `b` is string then we cannot have return value of number. Thus, TypeScript will raise [error that it cannot apply `+` operator between string and number](focus://6[28:32]).

</CH.Section>

<hr/>

<CH.Section>

Let's think of another example. This time, we will add new number parameter of `c`. That is, `a` and `b` are required, but `c` is an optional.

```ts
type Add = {
    (a: number, b: number): number
    (a: number, b: number, c: number): number
}

// withClass[7:9] code-error
const add: Add = (a, b, c) => a + b; // Type '(a: number, b: number, c: number) => number' is not assignable to type 'Add'.(2322)
```

In this case, [it raises error that it cannot infer type for parameter `c`](focus://6[7:9]). In TypeScript we need to specify types for extra parameters if we have different number of them.

</CH.Section>

Therefore, we can resolve errors as follows.

```ts
const add: Add = (a, b, c?: number) => a + b;
```

<br/>

## Generics

### Polymorphism

Polymorphism indicates it can have multiple forms. It can have multiple forms by having a variety of types and thus return value types will **dynamically **change accrodingly. Let's take an example.

```ts
type PrintEachElement = {
    (arr: Array<number>): void
    (arr: Array<string>): void
    (arr: Array<boolean>): void
}

const printEachElement: PrintEachElement = (arr) => {
    arr.forEach(el => console.log(el));
}

printEachElement([1, 2, 3, 4])
printEachElement(["a", "b", "c", "d"])
printEachElement([true, true, false, true])
```

`printEachElement` is a function that prints all elements in an array.
With type `PrintEachElement`, we can accept array that consists of only with either strings, numbers or booleans.

But what if there are other types mixed within this array?

```ts
type PrintEachElement = {
    (arr: Array<number>): void
    (arr: Array<string>): void
    (arr: Array<boolean>): void
}

const printEachElement: PrintEachElement = (arr) => {
    arr.forEach(el => console.log(el));
}

// withClass[19:20] code-error
printEachElement([1, "2"])
```

By doing this it will throw an error as below.

```
No overload matches this call.
  Overload 2 of 3, '(arr: string[]): void', gave the following error.
    Type 'number' is not assignable to type 'string'.(2769)
```

In other words, number type element `1` cannot be within an array that only consists of string elements.
Therefore we need to create multiple call signatures that satisfy all categories, which is quite cumbersome.

```ts
type PrintEachElement = {
    (arr: Array<number>): void
    (arr: Array<string>): void
    (arr: Array<boolean>): void
    (arr: Array<string | number>): void
    (arr: Array<string | boolean>): void
    // ...
}
```

<br/>

### Using generics types

Here we can apply <a href="https://www.typescriptlang.org/docs/handbook/2/generics.html#hello-world-of-generics" target="_blank">generics</a>.
Generics are tools that help TypeScript infer types when we are not sure which types will be in our call signatures.

We can edit `PrintEachElement` type with using generics as below.

<CH.Section>

```ts
type PrintEachElement = {
    <T>(arr: Array<T>): void
}

printEachElement([1, 2, 3, 4]) // const printEachElement: <number>(arr: number[]) => void
printEachElement(["a", "b", "c", "d"]) // const printEachElement: <string>(arr: string[]) => void
printEachElement([true, true, false, true]) // const printEachElement: <boolean>(arr: boolean[]) => void
printEachElement([1, "2", true]) // const printEachElement: <string | number | boolean>(arr: (string | number | boolean)[]) => void
```

1. First, put [`<T>`](focus://2[5:7]) in where we accept parameters so that it can tell TypeScript that this type is actually generics.
2. Put another [`<T>` at back](focus://2[19:21]) so that parameter `arr` can infer each elements of the array with [referring previous `T`](focus://2[5:7]).

</CH.Section>

By doing this, TypeScript will smartly return call signature that shows types of elements of array automatically no matter which types of values are in that array.

<br/>

### Constraints

As you might have noticed, generics are quite **dynamic**. But we can constrain types of generics. Let's take an another example.

<CH.Section>

```ts
function mergeObjects<T, U>(objA: T, objB: U) {
    // withClass[26:29] code-error
    return Object.assign(objA, objB);
}

const mergedObj = mergeObjects({name: "Apensia", hobbies: ["Coding"]}, 30);
console.log(mergedObj);
```

`mergeObjects` function takes parameters of `objA` and `objB` whose types are all object and merge objects with using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank">`.assign()`</a> method.
But we will have [an error that we cannot apply object type for parameter `objA`](focus://2[26:29]).

</CH.Section>

```
No overload matches this call.
  Overload 1 of 4, '(target: {}, source: U): {} & U', gave the following error.
    Argument of type 'T' is not assignable to parameter of type '{}'.
  Overload 2 of 4, '(target: object, ...sources: any[]): any', gave the following error.
    Argument of type 'T' is not assignable to parameter of type 'object'.(2769)
```

<br/>

According to Stack Overflow answer that I found, as type definitions of all methods for class <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank">`Object`</a> are changed,
I needed to specify types for each parameters being passed[^2]. Here we can use <a href="https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints" target="_blank">Constraints</a>, which means we can <ins>constrain</ins> types of parameters being passed.

<CH.Section>

```ts
// mark[25:38]
function mergeObjects<T extends object, U extends object>(objA: T, objB: U) {
    return Object.assign(objA, objB);
}

// withClass[72:73] code-error
const mergedObj = mergeObjects({name: "Apensia", hobbies: ["Coding"]}, 30); // Argument of type 'number' is not assignable to parameter of type 'object'.(2345)
console.log(mergedObj);
```

We can just specify types to constrain with using `extends` keyword within generics. For this case, I restricted generic types of `T` and `U` to be all obejcts(`object`) types.
Now [value `30` will occur type error as it is not an `object` type](focus://5[72:73]) which was passed as value of `objB`.

</CH.Section>

<br/>

#### Putting constraints on other type parameters

We can <a href="https://www.typescriptlang.org/docs/handbook/2/generics.html#using-type-parameters-in-generic-constraints" target="_blank">declare a type parameter that is constrained by another type parameter</a> in TypeScript.
What does this mean? Let's take a look at the code below.

```ts
function retrieveObjValue(obj: object, key: string) {
    // withClass[36:43] code-error
    return `Value for ${key} is` + obj[key]
}

console.log(retrieveObjValue({}, "name"))
```

<br/>

`retrieveObjValue()` function simply returns value of corresponding `key` of `obj` object.
It seems it does not have any problems when intuitively wrote down types but we will have a following errors.

```
Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{}'.
  No index signature with a parameter of type 'string' was found on type '{}'.(7053)
```

<br/>

Error above explains that TypeScript does not trust whether `obj` object will have `key` value always or not.
Therefore, we need to tell TypeScript that there is always `key` value within object `obj` <ins>by adding Contraint</ins>.

<br/>

<CH.Section>

```ts
function retrieveObjValue<T extends object, U extends keyof T>(obj: T, key: U) {
    return "Value: " + obj[key]
}

// withClass[34:39] code-error
console.log(retrieveObjValue({}, "name")); // Argument of type 'string' is not assignable to parameter of type 'never'.(2345)
console.log(retrieveObjValue({name: "Apensia"}, "name"));

```

We can accomplish this by using [`keyof` keyword so that `U` type always exists as key value of `T` type](focus://1[45:62]).

</CH.Section>

## References

[^1]: Call signature is pretty much blueprint of showing types of parameters and return value of a function.
[^2]:
    <a href="https://stackoverflow.com/a/42421502/13121145" target="_blank">error TS2345: Argument of type 'T' is not assignable to parameter of type 'object'</a>
