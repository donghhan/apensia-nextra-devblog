---
title: 직렬화 및 DRF 함수형 View
image: https://course.oc-static.com/courses/7107341/7107341_teaser_picture_1633008310.jpg
description: JSONResponse, ModelSerializer 및 함수형 GET, POST View 작성해보기
date: November 9th, 2022
---

import Callout from 'nextra-theme-docs/callout'
import Bleed from 'nextra-theme-docs/bleed'

# 직렬화 및 DRF 함수형 View

## Rest API란?

<a href="https://en.wikipedia.org/wiki/API" target="_blank">API (Application Programming Interface)</a>란 쉽게 얘기하여 <ins>서로 다른 두 컴퓨터가 어떤 식으로 정보를 주고받는지를 나타내는 방식</ins>을 가리킨다.
여기서 **REST**라는 단어의 의미는 Representational State Transfer의 약자로써 자원을 명시하고 HTTP에서 제공해주는 메소드들을 통해 해당 자원에 대한 CRUD를 적용하는 것을 의미한다.

클라이언트는 URI(Uniform Resource Identifier)를 통해 원하는 자원 상태에 대한 조작을 서버 측에 요청한다. 이 때, HTTP 프로토콜이 지정하는 메소드를 통해

## 순수 Django로 API 만들기

먼저 우리가 만든 가장 작은 단위의 모델인 `categories`부터 만져보도록 하자.

<br/>

### `Category` 모델 클래스

아래와 같이 간단하게 `Category` 모델 클래스를 만들어보았다.
letsh 서비스는 주거 공간 뿐만이 아니라 주차장 및 교통수단도 공유가 가능하기 때문에 공유 아이템 카테고리가 여러 모델에 사용될 가능성이 농후해보였다.

<br/>

<CH.Section>

[`kind`](focus://18[5:9])는 카테고리를 이루는 대분류에 해당하는 부분이다. 대분류는 선택할 수 있는 값들을 한정짓기 위하여 <a href="https://docs.djangoproject.com/en/4.1/ref/models/fields/#enumeration-types" target="_blank"><code>choices</code>의 enumeration type</a>을 사용해주었다.
그리고 [`name`](focus://17[5:9])은 소분류로써 <a href="https://docs.djangoproject.com/en/4.1/ref/models/fields/#django.db.models.CharField" target="_blank"><code>CharField</code></a>를 이용하여 자유롭게 설정할 수 있도록 해주었다.

```py categories/models.py
from django.db import models
from django.utils.translation import gettext_lazy as _
from common.models import TimeStampModel


class Category(TimeStampModel):

    """Category Model Definition"""

    class CategoryKindChoices(models.TextChoices):
        ROOM = ("room", "Room")
        HOUSE = ("house", "House")
        HOTEL_APARTMENT = ("hotel", "Hotel Apartments")
        PARKING = ("parking", "Parking")
        MOBILE = ("mobile", "Mobile")

    name = models.CharField(max_length=200)
    kind = models.CharField(
        max_length=20,
        choices=CategoryKindChoices.choices,
        default=CategoryKindChoices.ROOM,
    )

    def __str__(self):
        return f"{self.kind}: {self.name}"

    class Meta:
        verbose_name = _("Category")
        verbose_name_plural = _("Categories")
        db_table = "categories"
```

</CH.Section>

<br/>

### URL 설정하기

먼저 프로젝트의 설정 폴더 내의 `urls.py` 파일에서 우리가 만든 앱 `categories` 앱을 연결시켜줄 수 있는 루트 URL을 설정해주자.

<a href="https://docs.djangoproject.com/en/4.1/ref/urls/#include" target="_blank"><code>include()</code></a> 메소드는 각 앱들에 대한 루트 URL을 설정해줄 수 있다. 
<a href="https://docs.djangoproject.com/en/4.1/ref/urls/#path" target="_blank"><code>path()</code></a>의 첫번째 인자인 `route`에는 `api/v1/categories/`를,
그 다음 인자인 `view`에는 그에 상응하는 루트 URL을 `include`로 연결해주었다.

```py config/settings.py
"""
config URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/4.0/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path("admin/", admin.site.urls),
    # mark[5:59]
    path("api/v1/categories/", include("categories.urls")),
]
```

<br/>

이후 `categories` 앱 내부에 `urls.py`라는 새로운 파일을 만들고 세부 URL을 설정해준다.
아래 코드에서 `path()`의 첫번째 인자로 빈 문자열 `""`를 넣은 것은 유저가 `api/v1/categories/`로 갔을 때 맨 처음으로 보이는 View가 되게끔 하기 위해서이다.
두번째 인자로 들어가야 할 변수는 `view`인데 아직 `view`를 정의하지 못했으니 `view`를 정의해보도록 하자.

```py wishlists/urls.py
from django.urls import path
from .views import *

urlpatterns = [
    path("", categories)
]
```

<br/>

### View 설정하기

위의 URL에 걸맞는 함수형 View를 작성해보자.

<a href="https://docs.djangoproject.com/en/4.1/ref/request-response/#jsonresponse-objects" target="_blank"><code>JsonResponse</code></a>를 이용하여
통신이 원활하게 작동했을 때를 가리키는 `"ok"`와 카테고리 데이터인 `"categories"`를 JSON 파일에 담아서 전송하도록 한다.

```py
from django.http import JsonResponse
from .models import *


def wishlists(request):
    all_wishlists = Wishlist.objects.all()
    return JsonResponse({"ok": True, "wishlists": all_wishlists})
```

<br/>

그런데 이 경우 다음과 같이 `TypeError: Object of type QuerySet is not JSON serializable` 에러가 발생하게 된다.

<br/>

<center>![typeerror_notjsonserializable](../../media/backend/drf-serializers-get-and-post/typeerror_notjsonserializable.png)</center>

이는 단순히 얘기해서 우리의 브라우저가 QuerySet을 읽어들이지 못하고 있으며, 그 이유는 QuerySet을 무슨 이유에선지 JSON 형태의 파일로 변환하지 못하고 있기 때문이다.
그렇기 때문에 QuerySet을 JSON 형태로 한 번 더 바꿔주는 작업을 해야 한다.

### Django 객체 직렬화하기

<a href="https://en.wikipedia.org/wiki/Serialization" target="_blank">직렬화</a>란 특정 데이터 구조 혹은 객체를 저장 가능하거나 전송되거나 재구성될 수 있도록 포맷을 바꿔주는 작업을 일컫는다.
Django는 모델을 <a href="https://docs.djangoproject.com/en/4.1/topics/serialization/#serialization-formats" target="_blank">다양한 형태</a>의 파일로 바꿔주는 <a href="https://docs.djangoproject.com/en/4.1/topics/serialization/" target="_blank">직렬화 프레임워크</a>를 지니고 있다.

<CH.Scrollycoding>

#### 모듈 불러오기

직렬화를 위하여 <a href="https://docs.djangoproject.com/en/4.1/topics/serialization/#serializing-data" target="_blank"><code>serializers</code></a> 모듈을 불러온다.

```py wishlists/views.py focus=2
from django.http import JsonResponse
from django.core import serializers
from .models import *


def categories(request):
    all_categories = Category.objects.all()
    return JsonResponse({"ok": True, "categories": all_categories})
```

---

#### 직렬화하기

다음으로 `all_wishlists`를 직렬화시킨다.

```py wishlists/views.py focus=8:10
from django.http import JsonResponse
from django.core import serializers
from .models import *


def categories(request):
    all_categories = Category.objects.all()
    return JsonResponse(
        {"ok": True, "categories": serializers.serialize("json", all_categories)}
    )
```

</CH.Scrollycoding>

그럼 아래와 같이 결괏값이 제대로 찍히는 것을 볼 수 있다.

<center>![result](../../media/backend/drf-serializers-get-and-post/result.png)</center>

<br/>

### 한계

다만, 이러한 방식의 문제점은 각 View 별로 매번 이런 작업들을 수동적으로 해줘야 한다는 뜻이고 가끔씩 우리가 숨기고 싶은 불필요한 정보들을 손쉽게 제어할 수 없다는 점이다.
따라서 Django에 내장되어 있는 직렬화 프레임워크는 아무래도 사용하는데에는 힘든 구석이 꽤 있다.

<br/>

## DRF 직렬화 및 함수형 GET View

<a href="https://www.django-rest-framework.org/" target="_blank">Django Rest Framework (이하 DRF)</a>는 이러한 문제점을 해결해줄 수 있는 유명한 프레임워크다.
단순히 직렬화 뿐만이 아니라 인증/인가 절차, 허용 범위 등 Rest API에 다양한 기능들을 추가해줄 수 있는 유용한 유틸리티들을 제공한다.

### 설치

먼저 <a href="https://www.django-rest-framework.org/#installation" target="_blank">DRF를 설치</a>하도록 하자.

```bash
# pip 사용 시
pip install djangorestframework

# pipenv 사용 시
pipenv install djangorestframework

# poetry 사용 시
poetry add djangorestframework
```

<br/>

이후 앞선 시간에 나눴던 `THIRDPARTY_APPS` 부분에 DRF를 추가시켜준다.

```py config/settings.py
THIRDPARTY_APPS = ["rest_framework"]
```

<br/>

<CH.Scrollycoding>

### View 수정 (1차)

DRF를 도입하였으니 이제 본격적으로 View를 수정해보도록 하자.

#### `@api_view()`

먼저 함수형 View에서 사용할 수 있는 <a href="https://www.django-rest-framework.org/api-guide/views/#api_view" target="_blank"><code>@api_view()</code></a> 데코레이터를 불러온다.
여기서 <a href="https://docs.python.org/3/glossary.html#term-decorator" target="_blank">데코레이터</a>란 이미 만들어져있는 기존의 코드를 수정하지 않고도 `wrapper` 함수를 이용하여
다양한 기능들을 추가할 수 있게 만들어주는 파이썬의 유용한 문법 중 하나이다.
`@api_view()` 데코레이터 내부의 파라미터로써 HTTP 메소드를 지정할 수 있다. 즉, `GET`, `POST`, `PUT`, `DELETE` 등 본인이 원하는 HTTP 메소드를 지정할 수 있다.

<a href="https://www.django-rest-framework.org/api-guide/responses/#response" target="_blank"><code>Response</code></a> 클래스는 클라이언트의 요청에 따라 다양한 형태의 데이터로 바꾸어
응답을 처리해주는 역할을 수행한다.

```py wishlists/views.py focus=1:2
from rest_framework.decorators import api_view
from rest_framework.response import Response
from .models import *


def categories(request):
    all_categories = Category.objects.all()
    return JsonResponse(
        {"ok": True, "categories": serializers.serialize("json", all_categories)}
    )
```

---

#### View 수정

이후 View를 약간 수정해보자. 앞서 불러온 `@api_view()` 데코레이터를 `categories` View 상단에 불러온다.
또한, 아까 전에는 불러와지지 않았던 QuerySet을 불러와보자.

```py wishlists/views.py focus=6,9
from rest_framework.decorators import api_view
from rest_framework.response import Response
from .models import *


@api_view()
def categories(request):
    all_categories = Category.objects.all()
    # mark[34:70]
    return Response({"ok": True, "categories": Category.objects.all()})
```

</CH.Scrollycoding>

하지만 위 방법으로는 여전히 `TypeError: Object of type QuerySet is not JSON serializable` 에러가 발생하는 것을 알 수 있다.
즉, 여전히 브라우저는 우리가 제공하는 QuerySet을 읽어들이지 못하고 있는 것이다.

<br/>

### View 수정 (2차)

이 문제를 해결하기 위해 앞서 우리가 했었던 직렬화 작업을 한 번 더 해보도록 하자.
이번에는 Django가 아닌 DRF가 제공해주는 방법을 활용해 볼 것이다.

#### 직렬화 파일 생성

DRF의 직렬화를 사용하기 위해 `categories/` 폴더 내부에 `serializers.py` 파일을 생성한다.

```bash
touch categories/serializers.py
```

<br/>

<CH.Scrollycoding>

#### `ModelSerializer`

<a href="https://www.django-rest-framework.org/api-guide/serializers/#modelserializer" target="_blank"><code>ModelSerializer</code></a>를 통해 일일히 필드를 구성할 필요 없이 모델을 손쉽게 직렬화해줄 수 있다.

`categories/` 앱 경로에 `serializers.py` 파일을 만든 후, 본인이 원하는 필드를 <a href="https://www.django-rest-framework.org/api-guide/serializers/#specifying-which-fields-to-include" target="_blank">`fields`</a>에 추가하면 된다.
필자의 경우 `Category` 모델에 있는 필드 수가 그리 많지 않으므로 모든 필드를 뜻하는 `__all__`을 집어넣어 주었다.

```py categories/serializers.py
from rest_framework.serializers import ModelSerializer
from .models import *


class CategorySerializer(ModelSerializer):
    class Meta:
        model = Category
        fields = "__all__"

```

---

#### QuerySet 직렬화하기

앞서 만든 직렬화를 사용할 수 있도록 `serializers.py` 파일을 불러와준다.

모든 카테고리에 대한 QuerySet을 `all_categories`라는 변수에 담아 저장하였고, <a href="https://www.django-rest-framework.org/api-guide/serializers/#serializing-objects" target="_blank">QuerySet을 직렬화하기 위해</a> `serializer` 변수를 만들었다.

```py wishlists/views.py focus=4,10,11
from rest_framework.decorators import api_view
from rest_framework.response import Response
from .models import *
from .serializers import *


@api_view()
def categories(request):
    all_categories = Category.objects.all()
    serializer = CategorySerializer(all_categories)
    print(dir(serializer))
```

</CH.Scrollycoding>

<br/>

`dir(serializer)`를 콘솔에 출력해보면 아래와 같이 다양한 프로퍼티들이 담긴 것을 알 수 있다.

<br/>

<center>![properties](../../media/backend/drf-serializers-get-and-post/properties.png)</center>

<CH.Scrollycoding>

#### `Response` 반환하기

마지막으로 직렬화된 QuerySet을 접근할 수 있도록 <a href="https://www.django-rest-framework.org/api-guide/responses/#response" target="_blank"><code>Response()</code></a>를 이용한다.
위의 이미지에서 `serializer` 객체는 `data`에 접근할 수 있음을 알 수 있다. 따라서, `Response()`의 인자로 `serializer.data`를 넘겨준다.

```py wishlists/views.py focus=11
from rest_framework.decorators import api_view
from rest_framework.response import Response
from .models import *
from .serializers import *


@api_view()
def categories(request):
    all_categories = Category.objects.all()
    serializer = CategorySerializer(all_categories)
    return Response(serializer.data)
```

</CH.Scrollycoding>

하지만 이번에는 다른 에러를 뱉는다.

<br/>

<center>![attributeerror](../../media/backend/drf-serializers-get-and-post/attributeerror.png)</center>

이 긴 내용의 에러의 한가지 핵심은 직렬기가 처리할 수 있는 데이터와 QuerySet 수의 차이이다.
`WishlistSerializer`는 `user`라는 필드가 있는 찜하기 QuerySet을 오직 하나를 바꾸기 위해 만들어졌다.
하지만 View에서의 직렬기에 전달한 데이터는 단순히 하나가 아닌 여러 개를 전달하였기 때문에 이런 에러가 발생하는 것이다.

따라서 하나의 직렬기를 통해 여러 객체들을 직렬화시키길 원한다면 직렬기에 <a href="https://www.django-rest-framework.org/api-guide/serializers/?q=many%3DTrue#dealing-with-multiple-objects" target="_blank"><code>many=True</code></a>
를 전달해야 한다.
이는 오직 하나의 QuerySet을 전달할 때에는 그렇게 할 필요가 없다는 뜻도 된다.

```py wishlists/views.py
from rest_framework.decorators import api_view
from rest_framework.response import Response
from .models import *
from .serializers import *


@api_view()
def categories(request):
    all_categories = Category.objects.all()
    # mark[53:61]
    serializer = CategorySerializer(all_categories, many=True)
    return Response(serializer.data)
```

<br/>

### 결과

아래와 같이 성공적으로 JSON 형태로 데이터들이 불러와지는 것을 볼 수 있다.

<br/>

<center>![result2](../../media/backend/drf-serializers-get-and-post/result2.png)</center>

함수형 View에서의 POST 요청

저번 포스트에선 `GET` 요청에 대한 부분을 다뤄보았다.
이번엔 소분류 카테고리에 대해서 조회하고 새로운 소분류 카테고리를 생성할 수 있는 View를 만들어보자.

## 함수형 `POST` View

`POST` 요청은 <ins>**무언가를 새롭게 만들 때**</ins> 사용된다.

### View 수정 (3차)

<CH.Scrollycoding style={{ height: 400 }}>

#### URL 설정

`urls.py` 파일에서 이번엔 소분류 카테고리 하나만을 다루는 URL을 설정해보자.
고유 `id` 별로 소분류 카테고리를 가져오기 위해 <a href="https://docs.djangoproject.com/en/4.1/topics/http/urls/#path-converters" target="_blank">Path converter</a>를 사용해준다.
`id`는 `int` 형으로 가져왔다.

```py categories/urls.py
from django.urls import path
from .views import *

# mark[38:70]
urlpatterns = [path("", categories), path("<int:pk>", category_detail)]
```

---

#### HTTP Request 메소드 및 `GET` View 설정

특정 View에 대해서 특정 HTTP Request를 허용시키기 위해선 <a href="https://www.django-rest-framework.org/api-guide/views/#api_view" target="_blank">`@api_view()` 데코레이터에 본인이 원하는 요청을 넣어주면 된다</a>.
`GET` 요청의 경우 기본값으로 들어가게 된다.

`GET` 방식은 이전 포스트에서 했던 것과 동일하다. 다만, 소분류 카테고리 하나에 대한 부분을 다루므로 `pk`라는 파라미터를 추가적으로 전달한다.
`pk`는 앞서 위에서 적었던 `<int:pk>` 부분의 `pk`와 동일하게 이름을 적어야 한다.

`request.method`를 콘솔에 `print`를 해보면 해당 View가 현재 어떤 HTTP Request 메소드로 받고 있는지 `str` 값으로 알려준다.

```py categories/views.py focus=1,3,4:8
# mark[11:25]
@api_view(["GET", "POST"])
def categories(request):
    print(request.method) # GET
    if request.method == "GET":
        category = Category.objects.get(pk=pk)
        serializer = CategorySerializer(category)
        return Response(serializer.data)
```

---

#### `POST` View 설정

`POST` 요청도 마찬가지로 작성해준다.
여기서 `request.data`를 `print` 해보면 우리가 전송한 데이터가 JSON 형태로 보이게 된다.

```py categories/views.py focus=7:10
@api_view(["GET", "POST"])
def categories(request):
    if request.method == "GET":
        category = Category.objects.get(pk=pk)
        serializer = CategorySerializer(category)
        return Response(serializer.data)
    elif request.method == "POST":
        print(request.data) # {'name': 'Bed and Breakfast', 'kind': 'room'}
        return Response({"ok": True})
```

</CH.Scrollycoding>

그럼 다음과 같이 새롭게 데이터를 집어넣을 수 있는 란이 생기게 된다.

<br/>

<center>![result3](../../media/backend/drf-serializers-get-and-post/result3.png)</center>

<br/>

### 유효성 검사 및 저장

Serializer는 자체적인 유효성 검사도 실시한다. 예를 들어, 다음과 같이 길이가 20자가 넘어가는 `name`을 넘겨줬다고 가정해보자.

<br/>

<center>![invalid_attempt](../../media/backend/drf-serializers-get-and-post/invalid_attempt.png)</center>

<br/>

이는 잘못된 유형의 데이터이므로 DB에 업데이트가 되어서는 안된다.

<br/>

<center>![update_error](../../media/backend/drf-serializers-get-and-post/update_error.png)</center>

<CH.Scrollycoding>

#### `is_valid()`

<a href="https://www.django-rest-framework.org/api-guide/serializers/#validation" target="_blank">`is_valid()`</a> 메소드를 통해서 유저가 보내준 데이터가 유효한지 확인할 수 있다.
만일 유효하지 않다면 <a href="https://www.django-rest-framework.org/api-guide/serializers/#writable-nested-representations" target="_blank">`serializer.errors`</a>를 통해 해당 에러가 무엇인지 알 수 있다.

```py categories/models.py focus=9:10
@api_view(["GET", "POST"])
def categories(request):
    if request.method == "GET":
        all_categories = Category.objects.all()
        serializer = CategorySerializer(all_categories, many=True)
        return Response(serializer.data)
    elif request.method == "POST":
        serializer = CategorySerializer(data=request.data)
        print(serializer.is_valid()) # False
        print(serializer.errors) # {'name': [ErrorDetail(string='Ensure this field has no more than 20 characters.', code='max_length')]}
        return Response(serializer.data)
```

---

#### 데이터 유효성 검사에 따른 분기처리

따라서 만일 데이터가 유효할 경우에만 직렬화를 마친 데이터를 응답해주고, 그렇지 않을 경우 에러를 반환하도록 한다.

```py categories/models.py focus=9:12
@api_view(["GET", "POST"])
def categories(request):
    if request.method == "GET":
        all_categories = Category.objects.all()
        serializer = CategorySerializer(all_categories, many=True)
        return Response(serializer.data)
    elif request.method == "POST":
        serializer = CategorySerializer(data=request.data)
        if serializer.is_valid():
            return Response(serializer.data)
        else:
            return Response(serializer.errors)
```

---

#### 데이터 저장하기

유효성 검사가 끝나고 나게 되면 Serializer에 담긴 정보를 저장해보도록 하자. 이는 `.save()` 메소드를 통해 이루어진다.
만일 Serializer가 유저가 전달한 데이터로만 이루어져 있을 경우, `.save()` 메소드가 호출되는 순간 Serializer는 <a href="https://www.django-rest-framework.org/api-guide/serializers/#saving-instances" target="_blank">`create()` 메소드를 자동적으로 호출된다</a>.
그럼 `.create()` 메소드는 유효한 데이터를 가지고 새로운 객체를 생성하게 된다.

```py categories/models.py focus=10:11
@api_view(["GET", "POST"])
def categories(request):
    if request.method == "GET":
        all_categories = Category.objects.all()
        serializer = CategorySerializer(all_categories, many=True)
        return Response(serializer.data)
    elif request.method == "POST":
        serializer = CategorySerializer(data=request.data)
        if serializer.is_valid():
            new_category = serializer.save()
            return Response(CategorySerializer(new_category))
        else:
            return Response(serializer.errors)
```

</CH.Scrollycoding>

<br/>

## 함수형 `PUT` View

`PUT` Request는 무언가를 변경할 때 쓰인다.

<br/>

<CH.Scrollycoding>

### `PUT` Request 허용해주기

`@api_view()` 데코레이터 안에 `PUT` request를 허용해주도록 한다.

```py categories/views.py focus=1
# mark[19:23]
@api_view(["GET", "PUT"])
def category_detail(request, pk):
    try:
        category = Category.objects.get(pk=pk)
    except Category.DoesNotExist:
        raise NotFound

    if request.method == "GET":
        serializer = CategorySerializer(category)
        return Response(serializer.data)
    elif request.method == "PUT":
        serializer = CategorySerializer(category, data=request.data, partial=True)
        if serializer.is_valid():
            updated_category = serializer.save()
            return Response(CategorySerializer(updated_category).data)
        else:
            return Response(serializer.errors)
```

---

### 예외 처리

특정 카테고리를 수정하기 위해서는 먼저 해당 카테고리가 있는지부터 확인해야 한다.
만일 존재한다면 해당 카테고리 QuerySet을 <a href="https://docs.djangoproject.com/en/4.1/ref/models/querysets/#django.db.models.query.QuerySet.get" target="_blank">`.get()`</a>으로 가져오고,
존재하지 않는다면 <a href="https://www.django-rest-framework.org/api-guide/exceptions/#notfound" target="_blank">NotFound</a> 예외를 발생시킨다.

```py categories/views.py focus=3:7
# mark[19:23]
@api_view(["GET", "PUT"])
def category_detail(request, pk):
    try:
        category = Category.objects.get(pk=pk)
    except Category.DoesNotExist:
        raise NotFound

    if request.method == "GET":
        serializer = CategorySerializer(category)
        return Response(serializer.data)
    elif request.method == "PUT":
        serializer = CategorySerializer(category, data=request.data, partial=True)
        if serializer.is_valid():
            updated_category = serializer.save()
            return Response(CategorySerializer(updated_category).data)
        else:
            return Response(serializer.errors)
```

---

### `PUT` View 작성하기

#### `partial=True`

`serializer`는 크게 두 가지 데이터를 받는다.
하나는 앞서 `try` 문을 통해 DB에서 성공적으로 가져온 카테고리 QuerySet(`category`),
다른 하나는 유저가 보내준 데이터(`data=request.data`)이다.

하지만 가끔씩 유저가 보내주는 데이터는 항상 완전하다고 볼 수 없다 (예를 들어 필수적으로 포함되어야 하는 필드를 빠뜨렸다든지 등).
이를 위해 <ins>부분적으로만 업데이트</ins>가 되도록 <a href="https://www.django-rest-framework.org/api-guide/serializers/#partial-updates" target="_blank">`partial=True`</a>를 넣어주면 부분적 업데이트가 이루어진다.

```py categories/views.py focus=12
# mark[19:23]
@api_view(["GET", "PUT"])
def category_detail(request, pk):
    try:
        category = Category.objects.get(pk=pk)
    except Category.DoesNotExist:
        raise NotFound

    if request.method == "GET":
        serializer = CategorySerializer(category)
        return Response(serializer.data)
    elif request.method == "PUT":
        # mark[70:81]
        serializer = CategorySerializer(category, data=request.data, partial=True)
        if serializer.is_valid():
            updated_category = serializer.save()
            return Response(CategorySerializer(updated_category).data)
        else:
            return Response(serializer.errors)
```

---

#### 유효성 검사 및 저장

앞서 `POST` View 때와 마찬가지로 데이터가 유효하다는 것이 검증이 되었다면
해당 데이터를 직렬화하여 저장한다.

```py categories/views.py focus=13:15
# mark[19:23]
@api_view(["GET", "PUT"])
def category_detail(request, pk):
    try:
        category = Category.objects.get(pk=pk)
    except Category.DoesNotExist:
        raise NotFound

    if request.method == "GET":
        serializer = CategorySerializer(category)
        return Response(serializer.data)
    elif request.method == "PUT":
        # mark[70:81]
        serializer = CategorySerializer(category, data=request.data, partial=True)
        if serializer.is_valid():
            updated_category = serializer.save()
            return Response(CategorySerializer(updated_category).data)
        else:
            return Response(serializer.errors)
```

---

### `.update()` 메소드 수정

`.save()` 메소드가 실행될 경우 `POST` View와 같이 이번에는 <a href="https://www.django-rest-framework.org/api-guide/serializers/#saving-instances" target="_blank">`.update()` 메소드가 자동 실행</a>된다.

View에서 생성된 인스턴스의 각각의 필드에 대한 정보는 유효성 검증을 마친 `validated_data` 객체 내부의 필드이므로, 이를 연결해준 후 인스턴스를 저장하고 해당 인스턴스를 반환한다.

```py categories/serializers.py focus=9:13
class CategorySerializer(ModelSerializer):
    class Meta:
        model = Category
        fields = "__all__"

    def create(self, validated_data):
        return Category.objects.create(**validated_data)

    def update(self, instance, validated_data):
        instance.name = validated_data.get("name", instance.name)
        instance.kind = validated_data.get("kind", instance.kind)
        instance.save()
        return instance
```

</CH.Scrollycoding>

<br/>

### 결과

다음과 같이 성공적으로 `name`이 업데이트 되는 것을 확인할 수 있다.

<br/>

<center>![attempt](../../media/backend/drf-serializers-get-and-post/attempt.png)</center>

<br/>

<center>![success](../../media/backend/drf-serializers-get-and-post/success.png)</center>

<br/>

## 함수형 `DELETE` View

`DELETE` View는 굉장히 단순하다.

<br/>

<CH.Scrollycoding>

#### `DELETE` Request 허용해주기

`DELETE` Request를 허용해준다.

```py categories/views.py focus=20
from rest_framework.status import HTTP_204_NO_CONTENT

@api_view(["GET", "PUT", "DELETE"])
def category_detail(request, pk):
    try:
        category = Category.objects.get(pk=pk)
    except Category.DoesNotExist:
        raise NotFound

    if request.method == "GET":
        serializer = CategorySerializer(category)
        return Response(serializer.data)
    elif request.method == "PUT":
        serializer = CategorySerializer(category, data=request.data, partial=True)
        if serializer.is_valid():
            updated_category = serializer.save()
            return Response(CategorySerializer(updated_category).data)
        else:
            return Response(serializer.errors)
    elif request.method == "DELETE":
        category.delete()
        return Response(HTTP_204_NO_CONTENT)
```

---

#### 삭제 후 결과값 반환

카테고리 삭제 이후 성공적으로 삭제되었음을 알리는 <a href="https://www.django-rest-framework.org/api-guide/status-codes/#successful-2xx" target="_blank">`HTTP_204_NO_CONTENT`</a>를 반환한다.

```py categories/views.py focus=1,21:22
from rest_framework.status import HTTP_204_NO_CONTENT

@api_view(["GET", "PUT", "DELETE"])
def category_detail(request, pk):
    try:
        category = Category.objects.get(pk=pk)
    except Category.DoesNotExist:
        raise NotFound

    if request.method == "GET":
        serializer = CategorySerializer(category)
        return Response(serializer.data)
    elif request.method == "PUT":
        serializer = CategorySerializer(category, data=request.data, partial=True)
        if serializer.is_valid():
            updated_category = serializer.save()
            return Response(CategorySerializer(updated_category).data)
        else:
            return Response(serializer.errors)
    elif request.method == "DELETE":
        category.delete()
        return Response(HTTP_204_NO_CONTENT)
```

</CH.Scrollycoding>

<br/>

### 결과

다음과 같이 성공적으로 `name`이 업데이트 되는 것을 확인할 수 있다.

<br/>

<center>![delete_attempt](../../media/backend/drf-serializers-get-and-post/delete_attempt.png)</center>

<br/>

<center>![delete_successful](../../media/backend/drf-serializers-get-and-post/delete_successful.png)</center>
