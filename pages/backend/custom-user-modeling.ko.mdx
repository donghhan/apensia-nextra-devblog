---
title: Django 커스텀 User 모델 만들기 
image: https://course.oc-static.com/courses/7107341/7107341_teaser_picture_1633008310.jpg
description: 'Django에서 나만의 User 모델을 만들어보자.'
date: July 31st, 2022
---

import Callout from 'nextra-theme-docs/callout'
import Bleed from 'nextra-theme-docs/bleed'

# Django에서 커스텀 User 모델 만들기

Django에서 설명하고 있는 <a href="https://docs.djangoproject.com/en/4.0/intro/tutorial02/#creating-models" target="_blank">기본 방법</a>으로도 유저 모델을 충분히 구현해낼 수 있지만
매번 새로운 필드를 만드는 것도 귀찮은 작업을 피하고, 유저라고 하면 통상적으로 있어야 할 법한 정보들을 한꺼번에 불러와서 손쉽게 사용할 수 있으면 더욱 좋겠다.
그런 의미에서 Django에서 제공하는 좀 더 섹시한 방법으로 커스텀 User 모델을 만들어보자.

Django에서는 크게 2가지 방법으로 제시를 하고 있는데 이는 다음과 같다.[^1]

1. 기존 유저 모델에서 <a href="https://docs.djangoproject.com/en/4.0/topics/auth/customizing/#extending-user" target="_blank">확장</a>을 하는 방법
2. 기존 유저 모델을 <a href="https://docs.djangoproject.com/en/4.0/topics/auth/customizing/#auth-custom-user" target="_blank">대체</a>하는 방법

[^1]: 출처: <a href="https://docs.djangoproject.com/en/4.0/topics/auth/customizing/#customizing-authentication-in-django" target="_blank">Customizing authentication in Django</a>

<br/>

## 프로젝트 시작하기

프로젝트를 시작하는 부분은 <a href="https://www.apensiablog.dev/ko/backend/custom-validator-django#%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0" target="_blank">이 부분</a>을 참조하기 바란다.

<br/>

## 확장

`django.contrib.auth.models`의 `User`라는 기본적으로 제공되는 클래스에서
본인이 추가하거나 변경하고 싶은 세부 클래스들을 정의한 후, `User` 클래스를 세부 클래스들로 확장을 시키는 방법이다.

<br/>

<CH.Scrollycoding>

### `User` 클래스 상속하기

먼저 `User` 클래스를 import 해주자.

`User` 클래스의 코드를 기본적으로 살펴보면 (추후에 살펴볼) `AbstractUser`를 상속받고 있는 것을 알 수 있다.[^2]
[^2]: <a href="https://github.com/django/django/blob/6654289f5b350dfca3dc4f6abab777459b906756/django/contrib/auth/models.py#L405" target="_blank"><code>User</code> 클래스 코드</a>

따라서, 기본적으로 `username`과 `password`와 같이 필수 필드들과 나머지 부가적인 필드들을 제공한다.

```py users/models.py focus=2
from django.db import models
from django.contrib.auth.models import User


class Customer(models.Model):
    pass


class Admin(models.Model):
    pass
```

---

### 세부 클래스 생성하기

`User`라는 기본 클래스에 본인이 덧붙이고 싶은 세부 클래스들을 정의해보자.
예컨대, 이커머스 플랫폼의 경우 플랫폼을 사용하는 소비자와 플랫폼을 관리하는 어드민 유저가 있으니
이번 예제에선 그것들을 한 번 구현해보도록 하자.

```py users/models.py focus=5:6,9:10
from django.db import models
from django.contrib.auth.models import User


class Customer(models.Model):
    pass


class Admin(models.Model):
    pass
```

---

#### `Customer` 클래스 생성

`User`라는 클래스 내부의 정보까지 변경을 원한다면 <a href="https://docs.djangoproject.com/en/4.0/ref/models/fields/#django.db.models.OneToOneField" target="_blank"><code>OneToOneField</code></a>로 연결지어서
`User` 클래스와 `Customer` 클래스를 연결시켜준다.

그리고 그 밖에 `Customer` 클래스에 붙일 또다른 필드를 정의해주면 된다.
필자의 경우 `address`라는 필드를 새로 생성해주었다.

```py users/models.py focus=5:7
from django.db import models
from django.contrib.auth.models import User


class Customer(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    address = models.CharField(max_length=150)


class Admin(models.Model):
    pass
```

---

#### `Admin` 클래스 생성

어드민 유저를 위한 `Admin` 클래스를 생성해주었다.
이번에도 마찬가지로 `User` 클래스를 `admin_user`라는 프로퍼티와 함께 `OneToOneField`로 묶어주었다.

그리고 어드민 유저임을 표시하기 위해 `is_admin`이라는 <a href="https://docs.djangoproject.com/en/4.0/ref/models/fields/#booleanfield" target="_blank"><code>BooleanField</code></a>를 생성해주었다.

```py users/models.py focus=10:12
from django.db import models
from django.contrib.auth.models import User


class Customer(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    address = models.CharField(max_length=150)


class Admin(models.Model):
    admin_user = models.OneToOneField(User, on_delete=models.CASCADE)
    is_admin = models.BooleanField(default=True)
```

---

### `admin.py`에 등록하기

이제 우리가 만든 모델들을 `admin.py`에 연결시켜주자.
이를 위해 <a href="https://docs.djangoproject.com/en/4.0/ref/contrib/admin/#django.contrib.admin.InlineModelAdmin" target="_blank"><code>InlineModelAdmin</code></a> 방식을 사용해보도록 하겠다.

`User` 클래스에 내장되어 있는 <a href="https://github.com/django/django/blob/6654289f5b350dfca3dc4f6abab777459b906756/django/contrib/auth/admin.py#L44" target="_blank"><code>UserAdmin</code></a>를
`BaseUserAdmin`으로 alias를 줘서 import를 한 후, `UserAdmin` 클래스를 생성하고 연결시켜준다.

```py users/admin.py focus=2:4,15:20
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from django.contrib.auth.models import User
from .models import Customer, Admin


class CustomerInline(admin.StackedInline):
    pass


class AdminInline(admin.StackedInline):
    pass


class UserAdmin(BaseUserAdmin):
    inlines = []


admin.site.unregister(User)
admin.site.register(User, UserAdmin)

```

---

#### `CustomerInline` Admin 모델 만들기

앞서 만든 `Customer` 모델과 연결시키기 위한 `CustomerInline` Admin 모델을 생성해준다.

1. <a href="https://docs.djangoproject.com/en/4.0/ref/contrib/admin/#django.contrib.admin.InlineModelAdmin.model" target="_blank"><code>model</code></a> 프로퍼티에 앞서 만든 `Customer` 모델 클래스를 연결해준다.
2. <a href="https://docs.djangoproject.com/en/4.0/ref/contrib/admin/#django.contrib.admin.InlineModelAdmin.can_delete" target="_blank"><code>can_delete</code></a>에 `False` 값을 줌으로서 생성된 유저는 삭제될 수 없도록 만들었다.
> `can_delete` 프로퍼티는 만들고자 하는 서비스의 정책에 따라 `True` 혹은 `False`가 될 수 있을 것이다. 필자의 경우 공식 문서에 나온 내용 토대로 했지만 어드민이 (어떤 이유에서든) 유저를 삭제해야 할 필요가 있다면 기본값인 `True`로 놔둬도 괜찮을 것 같다.
3. <a href="https://docs.djangoproject.com/en/4.0/ref/contrib/admin/#django.contrib.admin.InlineModelAdmin.verbose_name_plural" target="_blank"><code>verbose_name_plural</code></a>를 설정해줌으로서 `Customer`들이 여러 개가 있을 때 Django admin 페이지에서 어떻게 보일지 설정해준다.

```py users/admin.py focus=7:10
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from django.contrib.auth.models import User
from .models import Customer, Admin


class CustomerInline(admin.StackedInline):
    model = Customer
    can_delete: bool = False
    verbose_name_plural: str = "Customers"


class AdminInline(admin.StackedInline):
    pass


class UserAdmin(BaseUserAdmin):
    inlines = []


admin.site.unregister(User)
admin.site.register(User, UserAdmin)
```

---

#### `AdminInline` Admin 모델 만들기

`Admin` 모델 클래스에 대한 Admin 모델도 위에서 살펴본 바와 같이 만들어준다.

```py users/admin.py focus=13:16
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from django.contrib.auth.models import User
from .models import Customer, Admin


class CustomerInline(admin.StackedInline):
    model = Customer
    can_delete: bool = False
    verbose_name_plural: str = "Customers"


class AdminInline(admin.StackedInline):
    model = Admin
    can_delete: bool = False
    verbose_name_plural: str = "Admin Users"


class UserAdmin(BaseUserAdmin):
    inlines = []


admin.site.unregister(User)
admin.site.register(User, UserAdmin)
```

---

#### `UserAdmin` Admin 모델 클래스와 붙여주기

앞서 불러온 `BaseUserAdmin`을 `UserAdmin`이라는 Admin 클래스에 상속으르 시킨 후,
위에서 만든 `CustomerInline`과 `AdminInline`을 연결시켜준다.

```py users/admin.py focus=19:20
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from django.contrib.auth.models import User
from .models import Customer, Admin


class CustomerInline(admin.StackedInline):
    model = Customer
    can_delete: bool = False
    verbose_name_plural: str = "Customers"


class AdminInline(admin.StackedInline):
    model = Admin
    can_delete: bool = False
    verbose_name_plural: str = "Admin Users"


class UserAdmin(BaseUserAdmin):
    inlines = (CustomerInline, AdminInline)


admin.site.unregister(User)
admin.site.register(User, UserAdmin)
```

</CH.Scrollycoding>

<br/>

### 결과

서버를 실행시키면 다음과 같은 화면을 볼 수 있다.
즉, 앞서 우리가 만든 `Customer`라는 세부 클래스에 정의된 `address` 필드 정보를 집어넣을 수 있고,
`Admin`이라는 세부 클래스에 정의된 `is_admin` 필드 정보를 집어넣을 수 있다.

<br/>

<center>![user_class](../../media/custom-user-django/user_class.png)</center>

<br/>

이후, 기본 정보들을 넣으면 추가로 부가적인 정보들을 넣을 수 있는 페이지로 넘어간다.

<br/>

<center>![user_class_second](../../media/custom-user-django/user_class_second.png)</center>

<br/>

Django admin 페이지에서 최종적으로 다음과 같이 보이게 된다.

<br/>

<center>![user_class_second](../../media/custom-user-django/user_class_dashboard.png)</center>

<br/>

## 대체

이번에는 좀 더 복잡하지만 더욱 커스터마이징 할 수 있는 방법으로 해보겠다.
이 포스트에선 <a href="https://docs.djangoproject.com/en/4.0/topics/auth/customizing/#django.contrib.auth.models.AbstractBaseUser" target="_blank"><code>AbstractBaseUser</code></a>의 방법을 사용해보겠다.

`AbstractBaseUser`에 대한 <a href="https://docs.djangoproject.com/en/4.0/topics/auth/customizing/#specifying-a-custom-user-model" target="_blank">공식 문서의 내용</a>에 따르면
의 경우 인증[^3]에 대한 기능만 있을 뿐 나머지 필드들은 전부 직접 구현을 해야하는 점이 특징이다.

[^3]: 참고: <a href="https://www.onelogin.com/learn/authentication-vs-authorization" target="_blank">인증과 인가의 차이점</a>

<Callout>
  `REQUIRED_FIELDS`를 설정해주지 않을 경우 
</Callout>
