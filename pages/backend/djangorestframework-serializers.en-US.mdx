---
title: DRF로 Rest API 만들기(1)
image: https://course.oc-static.com/courses/7107341/7107341_teaser_picture_1633008310.jpg
description: Django JSONResponse 및 ModelSerializer
date: November 8th, 2022
---

import Callout from 'nextra-theme-docs/callout'
import Bleed from 'nextra-theme-docs/bleed'

# 직렬화

## Rest API란?

<a href="https://en.wikipedia.org/wiki/API" target="_blank">API (Application Programming Interface)</a>란 쉽게 얘기하여 <ins>서로 다른 두 컴퓨터가 어떤 식으로 정보를 주고받는지를 나타내는 방식</ins>을 가리킨다.
여기서 **REST**라는 단어의 의미는 Representational State Transfer의 약자로써 자원을 명시하고 HTTP에서 제공해주는 메소드들을 통해 해당 자원에 대한 CRUD를 적용하는 것을 의미한다.

클라이언트는 URI(Uniform Resource Identifier)를 통해 원하는 자원 상태에 대한 조작을 서버 측에 요청한다. 이 때, HTTP 프로토콜이 지정하는 메소드를 통해

## 순수 Django로 API 만들기

먼저 우리가 만든 가장 작은 단위의 모델인 `categories`부터 만져보도록 하자.

<br/>

### `Category` 모델 클래스

아래와 같이 간단하게 `Category` 모델 클래스를 만들어보았다.
letsh 서비스는 주거 공간 뿐만이 아니라 주차장 및 교통수단도 공유가 가능하기 때문에 공유 아이템 카테고리가 여러 모델에 사용될 가능성이 농후해보였다.

`kind`는 카테고리를 이루는 대분류에 해당하는 부분이다. 대분류는 선택할 수 있는 값들을 한정짓기 위하여 <a href="https://docs.djangoproject.com/en/4.1/ref/models/fields/#enumeration-types" target="_blank"><code>choices</code>의 enumeration type</a>을 사용해주었다.
그리고 `name`은 소분류로써 <a href="https://docs.djangoproject.com/en/4.1/ref/models/fields/#django.db.models.CharField" target="_blank"><code>CharField</code></a>를 이용하여 자유롭게 설정할 수 있도록 해주었다.

```py categories/models.py
from django.db import models
from django.utils.translation import gettext_lazy as _
from common.models import TimeStampModel


class Category(TimeStampModel):

    """Category Model Definition"""

    class CategoryKindChoices(models.TextChoices):
        ROOM = ("room", "Room")
        HOUSE = ("house", "House")
        HOTEL_APARTMENT = ("hotel", "Hotel Apartments")
        PARKING = ("parking", "Parking")
        MOBILE = ("mobile", "Mobile")

    name = models.CharField(max_length=200)
    kind = models.CharField(
        max_length=20,
        choices=CategoryKindChoices.choices,
        default=CategoryKindChoices.ROOM,
    )

    def __str__(self):
        return f"{self.kind}: {self.name}"

    class Meta:
        verbose_name = _("Category")
        verbose_name_plural = _("Categories")
        db_table = "categories"
```

<br/>

### URL 설정하기

먼저 프로젝트의 설정 폴더 내의 `urls.py` 파일에서 우리가 만든 앱 `categories` 앱을 연결시켜줄 수 있는 루트 URL을 설정해주자.

<a href="https://docs.djangoproject.com/en/4.1/ref/urls/#include" target="_blank"><code>include()</code></a> 메소드는 각 앱들에 대한 루트 URL을 설정해줄 수 있다. 
<a href="https://docs.djangoproject.com/en/4.1/ref/urls/#path" target="_blank"><code>path()</code></a>의 첫번째 인자인 `route`에는 `api/v1/categories/`를,
그 다음 인자인 `view`에는 그에 상응하는 루트 URL을 `include`로 연결해주었다.

```py config/settings.py
"""
config URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/4.0/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path("admin/", admin.site.urls),
    # mark[5:59]
    path("api/v1/categories/", include("categories.urls")),
]
```

<br/>

이후 `categories` 앱 내부에 `urls.py`라는 새로운 파일을 만들고 세부 URL을 설정해준다.
아래 코드에서 `path()`의 첫번째 인자로 빈 문자열 `""`를 넣은 것은 유저가 `api/v1/categories/`로 갔을 때 맨 처음으로 보이는 View가 되게끔 하기 위해서이다.
두번째 인자로 들어가야 할 변수는 `view`인데 아직 `view`를 정의하지 못했으니 `view`를 정의해보도록 하자.

```py wishlists/urls.py
from django.urls import path
from .views import *

urlpatterns = [
    path("", categories)
]
```

<br/>

### View 설정하기

위의 URL에 걸맞는 함수형 View를 작성해보자.

<a href="https://docs.djangoproject.com/en/4.1/ref/request-response/#jsonresponse-objects" target="_blank"><code>JsonResponse</code></a>를 이용하여
통신이 원활하게 작동했을 때를 가리키는 `"ok"`와 카테고리 데이터인 `"categories"`를 JSON 파일에 담아서 전송하도록 한다.

```py
from django.http import JsonResponse
from .models import *


def wishlists(request):
    all_wishlists = Wishlist.objects.all()
    return JsonResponse({"ok": True, "wishlists": all_wishlists})
```

<br/>

그런데 이 경우 다음과 같이 `TypeError: Object of type QuerySet is not JSON serializable` 에러가 발생하게 된다.

<br/>

<center>![typeerror_notjsonserializable](../../media/drf-serializers/typeerror_notjsonserializable.png)</center>

이는 단순히 얘기해서 우리의 브라우저가 QuerySet을 읽어들이지 못하고 있으며, 그 이유는 QuerySet을 무슨 이유에선지 JSON 형태의 파일로 변환하지 못하고 있기 때문이다.
그렇기 때문에 QuerySet을 JSON 형태로 한 번 더 바꿔주는 작업을 해야 한다.

### Django 객체 직렬화하기

<a href="https://en.wikipedia.org/wiki/Serialization" target="_blank">직렬화</a>란 특정 데이터 구조 혹은 객체를 저장 가능하거나 전송되거나 재구성될 수 있도록 포맷을 바꿔주는 작업을 일컫는다.
Django는 모델을 <a href="https://docs.djangoproject.com/en/4.1/topics/serialization/#serialization-formats" target="_blank">다양한 형태</a>의 파일로 바꿔주는 <a href="https://docs.djangoproject.com/en/4.1/topics/serialization/" target="_blank">직렬화 프레임워크</a>를 지니고 있다.

<CH.Scrollycoding>

#### 모듈 불러오기

직렬화를 위하여 <a href="https://docs.djangoproject.com/en/4.1/topics/serialization/#serializing-data" target="_blank"><code>serializers</code></a> 모듈을 불러온다.

```py wishlists/views.py focus=2
from django.http import JsonResponse
from django.core import serializers
from .models import *


def categories(request):
    all_categories = Category.objects.all()
    return JsonResponse({"ok": True, "categories": all_categories})
```

---

#### 직렬화하기

다음으로 `all_wishlists`를 직렬화시킨다.

```py wishlists/views.py focus=8:10
from django.http import JsonResponse
from django.core import serializers
from .models import *


def categories(request):
    all_categories = Category.objects.all()
    return JsonResponse(
        {"ok": True, "categories": serializers.serialize("json", all_categories)}
    )
```

</CH.Scrollycoding>

그럼 아래와 같이 결괏값이 제대로 찍히는 것을 볼 수 있다.

<center>![result](../../media/drf-serializers/result.png)</center>

<br/>

## DRF 도입

### 한계

다만, 이러한 방식의 문제점은 각 View 별로 매번 이런 작업들을 수동적으로 해줘야 한다는 뜻이고 가끔씩 우리가 숨기고 싶은 불필요한 정보들을 손쉽게 제어할 수 없다는 점이다.
따라서 Django에 내장되어 있는 직렬화 프레임워크는 아무래도 사용하는데에는 힘든 구석이 꽤 있다.

<a href="https://www.django-rest-framework.org/" target="_blank">Django Rest Framework (이하 DRF)</a>는 이러한 문제점을 해결해줄 수 있는 유명한 프레임워크다.
단순히 직렬화 뿐만이 아니라 인증/인가 절차, 허용 범위 등 Rest API에 다양한 기능들을 추가해줄 수 있는 유용한 유틸리티들을 제공한다.

### 설치

먼저 <a href="https://www.django-rest-framework.org/#installation" target="_blank">DRF를 설치</a>하도록 하자.

```bash
# pip 사용 시
pip install djangorestframework

# pipenv 사용 시
pipenv install djangorestframework

# poetry 사용 시
poetry add djangorestframework
```

<br/>

이후 앞선 시간에 나눴던 `THIRDPARTY_APPS` 부분에 DRF를 추가시켜준다.

```py config/settings.py
THIRDPARTY_APPS = ["rest_framework"]
```

<br/>

<CH.Scrollycoding>

### View 수정

DRF를 도입하였으니 이제 본격적으로 View를 수정해보도록 하자.

#### `@api_view()`

먼저 함수형 View에서 사용할 수 있는 <a href="https://www.django-rest-framework.org/api-guide/views/#api_view" target="_blank"><code>@api_view()</code></a> 데코레이터를 불러온다.
여기서 <a href="https://docs.python.org/3/glossary.html#term-decorator" target="_blank">데코레이터</a>란 이미 만들어져있는 기존의 코드를 수정하지 않고도 `wrapper` 함수를 이용하여
다양한 기능들을 추가할 수 있게 만들어주는 파이썬의 유용한 문법 중 하나이다.
`@api_view()` 데코레이터 내부의 파라미터로써 HTTP 메소드를 지정할 수 있다. 즉, `GET`, `POST`, `PUT`, `DELETE` 등 본인이 원하는 HTTP 메소드를 지정할 수 있다.

<a href="https://www.django-rest-framework.org/api-guide/responses/#response" target="_blank"><code>Response</code></a> 클래스는 클라이언트의 요청에 따라 다양한 형태의 데이터로 바꾸어
응답을 처리해주는 역할을 수행한다.

```py wishlists/views.py focus=1:2
from rest_framework.decorators import api_view
from rest_framework.response import Response
from .models import *


def categories(request):
    all_categories = Category.objects.all()
    return JsonResponse(
        {"ok": True, "categories": serializers.serialize("json", all_categories)}
    )
```

---

#### View 수정

이후 View를 약간 수정해보자. 앞서 불러온 `@api_view()` 데코레이터를 `categories` View 상단에 불러온다.
또한, 아까 전에는 불러와지지 않았던 QuerySet을 불러와보자.

```py wishlists/views.py focus=6,9
from rest_framework.decorators import api_view
from rest_framework.response import Response
from .models import *


@api_view()
def categories(request):
    all_categories = Category.objects.all()
    # mark[34:70]
    return Response({"ok": True, "categories": Category.objects.all()})
```

</CH.Scrollycoding>

하지만 위 방법으로는 여전히 `TypeError: Object of type QuerySet is not JSON serializable` 에러가 발생하는 것을 알 수 있다.
즉, 여전히 브라우저는 우리가 제공하는 QuerySet을 읽어들이지 못하고 있는 것이다.

<br/>

## 직렬화

이 문제를 해결하기 위해 앞서 우리가 했었던 직렬화 작업을 한 번 더 해보도록 하자.
이번에는 Django가 아닌 DRF가 제공해주는 방법을 활용해 볼 것이다.

### 직렬화 파일 생성

DRF의 직렬화를 사용하기 위해 `categories/` 폴더 내부에 `serializers.py` 파일을 생성한다.

```bash
touch categories/serializers.py
```

<br/>

<CH.Scrollycoding>

### `ModelSerializer`

<a href="https://www.django-rest-framework.org/api-guide/serializers/#modelserializer" target="_blank"><code>ModelSerializer</code></a>를 통해 일일히 필드를 구성할 필요 없이 모델을 손쉽게 직렬화해줄 수 있다.

`categories/` 앱 경로에 `serializers.py` 파일을 만든 후, 본인이 원하는 필드를 <a href="https://www.django-rest-framework.org/api-guide/serializers/#specifying-which-fields-to-include" target="_blank">`fields`</a>에 추가하면 된다.
필자의 경우 `Category` 모델에 있는 필드 수가 그리 많지 않으므로 모든 필드를 뜻하는 `__all__`을 집어넣어 주었다.

```py categories/serializers.py
from rest_framework.serializers import ModelSerializer
from .models import *


class CategorySerializer(ModelSerializer):
    class Meta:
        model = Category
        fields = "__all__"

```

---

### QuerySet 직렬화하기

앞서 만든 직렬화를 사용할 수 있도록 `serializers.py` 파일을 불러와준다.

모든 카테고리에 대한 QuerySet을 `all_categories`라는 변수에 담아 저장하였고, <a href="https://www.django-rest-framework.org/api-guide/serializers/#serializing-objects" target="_blank">QuerySet을 직렬화하기 위해</a> `serializer` 변수를 만들었다.

```py wishlists/views.py focus=4,10,11
from rest_framework.decorators import api_view
from rest_framework.response import Response
from .models import *
from .serializers import *


@api_view()
def categories(request):
    all_categories = Category.objects.all()
    serializer = CategorySerializer(all_categories)
    print(dir(serializer))
```

</CH.Scrollycoding>

<br/>

`dir(serializer)`를 콘솔에 출력해보면 아래와 같이 다양한 프로퍼티들이 담긴 것을 알 수 있다.

<br/>

<center>![properties](../../media/drf-serializers/properties.png)</center>

<CH.Scrollycoding>

### `Response` 반환하기

마지막으로 직렬화된 QuerySet을 접근할 수 있도록 <a href="https://www.django-rest-framework.org/api-guide/responses/#response" target="_blank"><code>Response()</code></a>를 이용한다.
위의 이미지에서 `serializer` 객체는 `data`에 접근할 수 있음을 알 수 있다. 따라서, `Response()`의 인자로 `serializer.data`를 넘겨준다.

```py wishlists/views.py focus=11
from rest_framework.decorators import api_view
from rest_framework.response import Response
from .models import *
from .serializers import *


@api_view()
def categories(request):
    all_categories = Category.objects.all()
    serializer = CategorySerializer(all_categories)
    return Response(serializer.data)
```

</CH.Scrollycoding>

하지만 이번에는 다른 에러를 뱉는다.

<br/>

<center>![attributeerror](../../media/drf-serializers/attributeerror.png)</center>

이 긴 내용의 에러의 한가지 핵심은 직렬기가 처리할 수 있는 데이터와 QuerySet 수의 차이이다.
`WishlistSerializer`는 `user`라는 필드가 있는 찜하기 QuerySet을 오직 하나를 바꾸기 위해 만들어졌다.
하지만 View에서의 직렬기에 전달한 데이터는 단순히 하나가 아닌 여러 개를 전달하였기 때문에 이런 에러가 발생하는 것이다.

따라서 하나의 직렬기를 통해 여러 객체들을 직렬화시키길 원한다면 직렬기에 <a href="https://www.django-rest-framework.org/api-guide/serializers/?q=many%3DTrue#dealing-with-multiple-objects" target="_blank"><code>many=True</code></a>
를 전달해야 한다.
이는 오직 하나의 QuerySet을 전달할 때에는 그렇게 할 필요가 없다는 뜻도 된다.

```py wishlists/views.py
from rest_framework.decorators import api_view
from rest_framework.response import Response
from .models import *
from .serializers import *


@api_view()
def categories(request):
    all_categories = Category.objects.all()
    # mark[53:61]
    serializer = CategorySerializer(all_categories, many=True)
    return Response(serializer.data)
```

<br/>

## 결과

아래와 같이 성공적으로 JSON 형태로 데이터들이 불러와지는 것을 볼 수 있다.

<br/>

<center>![result2](../../media/drf-serializers/result2.png)</center>
