---
title: Django Modeling(1)
image: https://course.oc-static.com/courses/7107341/7107341_teaser_picture_1633008310.jpg
description: "What is abstract base class"
date: August 19th, 2022
---

import Callout from 'nextra-theme-docs/callout'
import Bleed from 'nextra-theme-docs/bleed'

# Django Model

In Django, <a href="https://docs.djangoproject.com/en/4.1/intro/tutorial02/#creating-models" target="_blank">Model</a> is a shape of data.
We can easily set up our own database with <a href="https://docs.djangoproject.com/en/4.1/ref/models/fields/#django.db.models.Field" target="_blank">fields</a> that Django provides to us
so that we don't need to jot down all complex SQL queries.

## Let's think about this...

When it comes to structuring backend, modeling would be the most difficult part.
I also thought of many different data fields while structuring Let'sh share-commerce platform.
As applicaiton service will getting bigger, it would require more complex data structure, but I ended up deciding to build up with minimalism.

1. User: Users that will be using my application
2. Share items: Sharable items of users such as accomodations and transportations
3. Reviews: Reviews that users left after using share items
4. Bookings: Bookings that users do before using share items
5. Direct messages: Messages that users share sent back and forth
6. Categories(ðŸŸ¨ Done after a while): Types of share items
7. Media: Any visual media that users share
8. Wishlists: Marking system for future use
9. Common: Common data models that can be shared throughout the other apps
10. ETC &rarr; Other things that will be done after all these things...

I thought of categories so that admin users can easily add up the type of sharable items when they needed.
However, I am not going to talk about it as it is beyond my MVP schedule.

<br/>

### Brainstorming

I named each apps' app labels as below.

<br/>

<center>
|        Description         |       Name        |
| :--------------------: | :---------------: |
|          Users          |      `users`      |
|   Share item (Accomodation)   |  `accomodations`  |
| Share item (Transportation) | `transportations` |
|          Reviews          |     `reviews`     |
|          Bookings       |  `bookings`   |
|         Direct Messages      |    `direct_messages`     |
|        Categories         |    `categories`     |
| Media | `user_media` |
| Wishlists | `wishlists` |
</center>

I separated accomodations and transportations although they are same sharable items.

<br/>

## Initializing project

_Coming soon_

<br/>

## Common model

Common model is a model that includes data that could be shared throughout other apps.
Time and users' address could be the best data type that can be used in this model.

### Abstract base model

However, including all these common data into all other apps' models is just repeating codes ourselves and it could waste our DB.
Therefore, I set this model as <a href="https://docs.djangoproject.com/en/4.1/topics/db/models/#abstract-base-classes" target="_blank">abstract base model</a>.
What that means is after I defined the common data fields, with using <a href="https://docs.python.org/3/tutorial/classes.html#inheritance" target="_blank">class inheritance</a>
other apps' models can also use Common model's data fields.

<br/>

### Coding

#### Creating app

Let's create `common` app with the following command. This is where we are going to define our common models.

```bash
django-admin startapp common
```

After that, let's include `common` app in our `settings.py`.
I separated <a href="https://docs.djangoproject.com/en/4.1/ref/settings/#installed-apps" target="_blank"><code>INSTALLED_APPS</code></a> in certain ways before my application gets too complicated.

1. `DJANGO_APPS`: Pre-installed Django apps
2. `THIRDPARTY_APPS`: Any third-party libraries
3. `MANUALLY_INSTALLED_APPS`: Apps that I installed by myself

and bundled them all up with `INSTALLED_APPS`.

```py config/settings.py
DJANGO_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
]

THIRDPARTY_APPS = []

MANUALLY_INSTALLED_APPS = [
    "common.apps.CommonConfig",
]

INSTALLED_APPS = DJANGO_APPS + THIRDPARTY_APPS + MANUALLY_INSTALLED_APPS
```

<br/>

<CH.Scrollycoding>

#### Creating model class

There could be multiple models depending on data.
To begin with, we are going to make model that deals with time.
I created class named `TimeStampModel`

```py focus=3:7
from django.db import models

class TimeStampModel(models.Model):

    """TimeStamp Model Definition"""

    pass
```

---

#### `Meta` class configuration

<a href="https://docs.djangoproject.com/en/4.1/topics/db/models/#meta-options" target="_blank"><code>Meta</code> class</a> allows us to do several configurations for our models.
As our `TimeStampModel` is abstract base model, I set `abstract = True` as explained in <a href="https://docs.djangoproject.com/en/4.1/topics/db/models/#abstract-base-classes" target="_blank">documentation</a>.

By doing this, we can use these fields in other models without creating DB table.

```py focus=9:10
from django.db import models

class TimeStampModel(models.Model):

    """TimeStamp Model Definition"""

    pass

    class Meta:
        abstract = True
```

---

#### `DateTimeField`

Finally, let's specify model field.

As you can literally tell from its name, <a href="https://docs.djangoproject.com/en/4.1/ref/models/fields/#django.db.models.DateTimeField" target="_blank"><code>DateTimeField</code></a>
controls date and time.
I created model field called `created_at` and `updated_at` for created time and updated time, respectively.

Meanwhile, <a href="https://docs.djangoproject.com/en/4.1/ref/models/fields/#django.db.models.DateField.auto_now_add" target="_blank"><code>auto_now_add</code></a> attribute sets date and time as now
when new object is <ins>newly created</ins>.

On the other hand, <a href="https://docs.djangoproject.com/en/4.1/ref/models/fields/#django.db.models.DateField.auto_now" target="_blank"><code>auto_now</code></a> attribute marks date and time as now
when the object is <ins>newly updated</ins>.

```py focus=7:8
from django.db import models

class TimeStampModel(models.Model):

    """TimeStamp Model Definition"""

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        abstract = True
```

</CH.Scrollycoding>
